<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>ESP8266_RTOS_SDK: Network Espconn APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESP8266_RTOS_SDK
   &#160;<span id="projectnumber">v1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Network Espconn APIs</div>  </div>
</div><!--header-->
<div class="contents">

<p>Network espconn APIs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__esp__tcp.html">_esp_tcp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__esp__udp.html">_esp_udp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__remot__info.html">_remot_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structespconn.html">espconn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0149e7f6afdf2a5aef57e1fbe19c0b65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga0149e7f6afdf2a5aef57e1fbe19c0b65">ESPCONN_OK</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga0149e7f6afdf2a5aef57e1fbe19c0b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45549b79bd5d005eaeabd547f9c9b8d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga45549b79bd5d005eaeabd547f9c9b8d6">ESPCONN_MEM</a>&#160;&#160;&#160;-1</td></tr>
<tr class="separator:ga45549b79bd5d005eaeabd547f9c9b8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444a33b46763426495ef6445427301f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga444a33b46763426495ef6445427301f2">ESPCONN_TIMEOUT</a>&#160;&#160;&#160;-3</td></tr>
<tr class="separator:ga444a33b46763426495ef6445427301f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22ce1e3a32571dd2ec6d755a77ac976c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga22ce1e3a32571dd2ec6d755a77ac976c">ESPCONN_RTE</a>&#160;&#160;&#160;-4</td></tr>
<tr class="separator:ga22ce1e3a32571dd2ec6d755a77ac976c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2d9a86577de714e72eb79e757b6e6d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gab2d9a86577de714e72eb79e757b6e6d2">ESPCONN_INPROGRESS</a>&#160;&#160;&#160;-5</td></tr>
<tr class="separator:gab2d9a86577de714e72eb79e757b6e6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b472e2b51197621984908dfe3a0984"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga35b472e2b51197621984908dfe3a0984">ESPCONN_MAXNUM</a>&#160;&#160;&#160;-7</td></tr>
<tr class="separator:ga35b472e2b51197621984908dfe3a0984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bf23d2d937c693c7d9a66ac609194bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga0bf23d2d937c693c7d9a66ac609194bc">ESPCONN_ABRT</a>&#160;&#160;&#160;-8</td></tr>
<tr class="separator:ga0bf23d2d937c693c7d9a66ac609194bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bae98a46863135cfb79a5296b41d058"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga2bae98a46863135cfb79a5296b41d058">ESPCONN_RST</a>&#160;&#160;&#160;-9</td></tr>
<tr class="separator:ga2bae98a46863135cfb79a5296b41d058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867f470db66f9ba20f7ea9a494fe6320"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga867f470db66f9ba20f7ea9a494fe6320">ESPCONN_CLSD</a>&#160;&#160;&#160;-10</td></tr>
<tr class="separator:ga867f470db66f9ba20f7ea9a494fe6320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39113d279962242d9ed0aaba5fc57c46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga39113d279962242d9ed0aaba5fc57c46">ESPCONN_CONN</a>&#160;&#160;&#160;-11</td></tr>
<tr class="separator:ga39113d279962242d9ed0aaba5fc57c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ab82f63b7e43bf6ea1c36653707b67d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga0ab82f63b7e43bf6ea1c36653707b67d">ESPCONN_ARG</a>&#160;&#160;&#160;-12</td></tr>
<tr class="separator:ga0ab82f63b7e43bf6ea1c36653707b67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4abb7c01f3e8465771f76aba5071c1fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga4abb7c01f3e8465771f76aba5071c1fd">ESPCONN_IF</a>&#160;&#160;&#160;-14</td></tr>
<tr class="separator:ga4abb7c01f3e8465771f76aba5071c1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb6b13a82c7a627b13faf308fe38981"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gadbb6b13a82c7a627b13faf308fe38981">ESPCONN_ISCONN</a>&#160;&#160;&#160;-15</td></tr>
<tr class="separator:gadbb6b13a82c7a627b13faf308fe38981"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac2f5cc499f1d963723ed37d87a029a00"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gac2f5cc499f1d963723ed37d87a029a00">espconn_connect_callback</a>) (void *arg)</td></tr>
<tr class="memdesc:gac2f5cc499f1d963723ed37d87a029a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect callback.  <a href="#gac2f5cc499f1d963723ed37d87a029a00">More...</a><br /></td></tr>
<tr class="separator:gac2f5cc499f1d963723ed37d87a029a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06024aeff44004ddbdb7044b97676bba"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga06024aeff44004ddbdb7044b97676bba">espconn_reconnect_callback</a>) (void *arg, sint8 err)</td></tr>
<tr class="memdesc:ga06024aeff44004ddbdb7044b97676bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconnect callback.  <a href="#ga06024aeff44004ddbdb7044b97676bba">More...</a><br /></td></tr>
<tr class="separator:ga06024aeff44004ddbdb7044b97676bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae391ef757d57a723ff4033fe4e4ea394"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae391ef757d57a723ff4033fe4e4ea394"></a>
typedef struct <a class="el" href="struct__esp__tcp.html">_esp_tcp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>esp_tcp</b></td></tr>
<tr class="separator:gae391ef757d57a723ff4033fe4e4ea394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c758392b989c00b5d33680d02ec30e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c758392b989c00b5d33680d02ec30e6"></a>
typedef struct <a class="el" href="struct__esp__udp.html">_esp_udp</a>&#160;</td><td class="memItemRight" valign="bottom"><b>esp_udp</b></td></tr>
<tr class="separator:ga4c758392b989c00b5d33680d02ec30e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d59e8507266d57f56ae8d19bea99b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga86d59e8507266d57f56ae8d19bea99b1"></a>
typedef struct <a class="el" href="struct__remot__info.html">_remot_info</a>&#160;</td><td class="memItemRight" valign="bottom"><b>remot_info</b></td></tr>
<tr class="separator:ga86d59e8507266d57f56ae8d19bea99b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c93b1b8d3455a8f4fdeb35b064c4b0f"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga5c93b1b8d3455a8f4fdeb35b064c4b0f">espconn_recv_callback</a>) (void *arg, char *pdata, unsigned short len)</td></tr>
<tr class="separator:ga5c93b1b8d3455a8f4fdeb35b064c4b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a7b0d1a5af8fafcb98a299c624cb4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga31a7b0d1a5af8fafcb98a299c624cb4e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>espconn_sent_callback</b>) (void *arg)</td></tr>
<tr class="separator:ga31a7b0d1a5af8fafcb98a299c624cb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6c8cf602f9c20d36003dc6d1b518d78"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gac6c8cf602f9c20d36003dc6d1b518d78">dns_found_callback</a>) (const char *name, ip_addr_t *ipaddr, void *callback_arg)</td></tr>
<tr class="memdesc:gac6c8cf602f9c20d36003dc6d1b518d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback which is invoked when a hostname is found.  <a href="#gac6c8cf602f9c20d36003dc6d1b518d78">More...</a><br /></td></tr>
<tr class="separator:gac6c8cf602f9c20d36003dc6d1b518d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga822c96862e04f46aff8d65cb8170b60f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga822c96862e04f46aff8d65cb8170b60f">espconn_type</a> { <a class="el" href="group__Espconn__APIs.html#gga822c96862e04f46aff8d65cb8170b60faf10957d87831780be73e55426e8da737">ESPCONN_INVALID</a> = 0, 
<a class="el" href="group__Espconn__APIs.html#gga822c96862e04f46aff8d65cb8170b60faf9113ca7b14a1637d2a0099367622879">ESPCONN_TCP</a> = 0x10, 
<a class="el" href="group__Espconn__APIs.html#gga822c96862e04f46aff8d65cb8170b60fa85d8592fc339ccda13561161ddfd63f7">ESPCONN_UDP</a> = 0x20
 }<tr class="separator:ga822c96862e04f46aff8d65cb8170b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga27ebed6341108494ecf41ec8a7d37c4b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga27ebed6341108494ecf41ec8a7d37c4b">espconn_state</a> { <br />
&#160;&#160;<a class="el" href="group__Espconn__APIs.html#gga27ebed6341108494ecf41ec8a7d37c4ba7dd74b008ab5d04f15ff84de4b70bf90">ESPCONN_NONE</a>, 
<a class="el" href="group__Espconn__APIs.html#gga27ebed6341108494ecf41ec8a7d37c4baa13c91321f9aef1bf5023f1ea18e093a">ESPCONN_WAIT</a>, 
<a class="el" href="group__Espconn__APIs.html#gga27ebed6341108494ecf41ec8a7d37c4ba97c2f022ffce819bc2658f4e5796543a">ESPCONN_LISTEN</a>, 
<a class="el" href="group__Espconn__APIs.html#gga27ebed6341108494ecf41ec8a7d37c4ba2581f4215688fddcb1852ea4cbbcdaef">ESPCONN_CONNECT</a>, 
<br />
&#160;&#160;<a class="el" href="group__Espconn__APIs.html#gga27ebed6341108494ecf41ec8a7d37c4bab7b47f073e3e6db0ce792ab8fff1df02">ESPCONN_WRITE</a>, 
<a class="el" href="group__Espconn__APIs.html#gga27ebed6341108494ecf41ec8a7d37c4ba01caf55e6b01ffa1089348102d42734c">ESPCONN_READ</a>, 
<a class="el" href="group__Espconn__APIs.html#gga27ebed6341108494ecf41ec8a7d37c4ba755ebf5af367126c8c2c33f8e919bac4">ESPCONN_CLOSE</a>
<br />
 }<tr class="separator:ga27ebed6341108494ecf41ec8a7d37c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga9db40198a52a9becd150a851f9855a92"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga9db40198a52a9becd150a851f9855a92">espconn_option</a> { <br />
&#160;&#160;<a class="el" href="group__Espconn__APIs.html#gga9db40198a52a9becd150a851f9855a92a9cb44b08d9f53701b054b08d04f7d71f">ESPCONN_START</a> = 0x00, 
<a class="el" href="group__Espconn__APIs.html#gga9db40198a52a9becd150a851f9855a92a8c4b05b4bdbd12c64f1809c48d99e395">ESPCONN_REUSEADDR</a> = 0x01, 
<a class="el" href="group__Espconn__APIs.html#gga9db40198a52a9becd150a851f9855a92a22a60c5e343e19f83f9facedc8cd6f89">ESPCONN_NODELAY</a> = 0x02, 
<a class="el" href="group__Espconn__APIs.html#gga9db40198a52a9becd150a851f9855a92a5a42c1ab1c6a9e2cce272046bce29687">ESPCONN_COPY</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="group__Espconn__APIs.html#gga9db40198a52a9becd150a851f9855a92a131641817461609c89b8086dd90f64a9">ESPCONN_KEEPALIVE</a> = 0x08, 
<a class="el" href="group__Espconn__APIs.html#gga9db40198a52a9becd150a851f9855a92ae2ad46665b977365b8cc24f2b325155f">ESPCONN_END</a>
<br />
 }<tr class="separator:ga9db40198a52a9becd150a851f9855a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:gaaae7451fb36d445e625d52b3f0eec36e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gaaae7451fb36d445e625d52b3f0eec36e">espconn_level</a> { <a class="el" href="group__Espconn__APIs.html#ggaaae7451fb36d445e625d52b3f0eec36ea858f5c8ad925f16f59eb728619235e8b">ESPCONN_KEEPIDLE</a>, 
<a class="el" href="group__Espconn__APIs.html#ggaaae7451fb36d445e625d52b3f0eec36ea9266ad9351007ce73e8877405970a6d8">ESPCONN_KEEPINTVL</a>, 
<a class="el" href="group__Espconn__APIs.html#ggaaae7451fb36d445e625d52b3f0eec36ea1e723b94b0ac601545a717261203eb1b">ESPCONN_KEEPCNT</a>
 }<tr class="separator:gaaae7451fb36d445e625d52b3f0eec36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:gadf764cbdea00d65edcd07bb9953ad2b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf764cbdea00d65edcd07bb9953ad2b7"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>ESPCONN_IDLE</b> = 0, 
<b>ESPCONN_CLIENT</b>, 
<b>ESPCONN_SERVER</b>, 
<b>ESPCONN_BOTH</b>, 
<br />
&#160;&#160;<b>ESPCONN_MAX</b>
<br />
 }<tr class="separator:gadf764cbdea00d65edcd07bb9953ad2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab1bd524be2b4c1b727e3519e3cae69bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gab1bd524be2b4c1b727e3519e3cae69bf">espconn_init</a> (void)</td></tr>
<tr class="memdesc:gab1bd524be2b4c1b727e3519e3cae69bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">espconn initialization.  <a href="#gab1bd524be2b4c1b727e3519e3cae69bf">More...</a><br /></td></tr>
<tr class="separator:gab1bd524be2b4c1b727e3519e3cae69bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949cd618667cea85b1b99d14b90dce7d"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga949cd618667cea85b1b99d14b90dce7d">espconn_connect</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>)</td></tr>
<tr class="memdesc:ga949cd618667cea85b1b99d14b90dce7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to a TCP server (ESP8266 acting as TCP client).  <a href="#ga949cd618667cea85b1b99d14b90dce7d">More...</a><br /></td></tr>
<tr class="separator:ga949cd618667cea85b1b99d14b90dce7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9969873c3b8ee86a34496a5166cf8bfc"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga9969873c3b8ee86a34496a5166cf8bfc">espconn_disconnect</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>)</td></tr>
<tr class="memdesc:ga9969873c3b8ee86a34496a5166cf8bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect a TCP connection.  <a href="#ga9969873c3b8ee86a34496a5166cf8bfc">More...</a><br /></td></tr>
<tr class="separator:ga9969873c3b8ee86a34496a5166cf8bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63d15dda14dfcd8da278c31f048910c3"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga63d15dda14dfcd8da278c31f048910c3">espconn_delete</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>)</td></tr>
<tr class="memdesc:ga63d15dda14dfcd8da278c31f048910c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a transmission.  <a href="#ga63d15dda14dfcd8da278c31f048910c3">More...</a><br /></td></tr>
<tr class="separator:ga63d15dda14dfcd8da278c31f048910c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd44446e3fc4a61fdef77d473deb678b"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gabd44446e3fc4a61fdef77d473deb678b">espconn_accept</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>)</td></tr>
<tr class="memdesc:gabd44446e3fc4a61fdef77d473deb678b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a TCP server (i.e. accepts connections).  <a href="#gabd44446e3fc4a61fdef77d473deb678b">More...</a><br /></td></tr>
<tr class="separator:gabd44446e3fc4a61fdef77d473deb678b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad55b9729c7629f40c8e7ae2d73f7f174"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gad55b9729c7629f40c8e7ae2d73f7f174">espconn_create</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>)</td></tr>
<tr class="memdesc:gad55b9729c7629f40c8e7ae2d73f7f174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create UDP transmission.  <a href="#gad55b9729c7629f40c8e7ae2d73f7f174">More...</a><br /></td></tr>
<tr class="separator:gad55b9729c7629f40c8e7ae2d73f7f174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7665768ea19f95957284938cc0af950"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gaa7665768ea19f95957284938cc0af950">espconn_tcp_get_max_con</a> (void)</td></tr>
<tr class="memdesc:gaa7665768ea19f95957284938cc0af950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum number of how many TCP connections are allowed.  <a href="#gaa7665768ea19f95957284938cc0af950">More...</a><br /></td></tr>
<tr class="separator:gaa7665768ea19f95957284938cc0af950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6281d28b05672dc10f702f0e5386fb98"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga6281d28b05672dc10f702f0e5386fb98">espconn_tcp_set_max_con</a> (uint8 num)</td></tr>
<tr class="memdesc:ga6281d28b05672dc10f702f0e5386fb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of how many TCP connection is allowed.  <a href="#ga6281d28b05672dc10f702f0e5386fb98">More...</a><br /></td></tr>
<tr class="separator:ga6281d28b05672dc10f702f0e5386fb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8418023ae67bd83742d7d2642c3d4da0"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga8418023ae67bd83742d7d2642c3d4da0">espconn_tcp_get_max_con_allow</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>)</td></tr>
<tr class="memdesc:ga8418023ae67bd83742d7d2642c3d4da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of TCP clients which are allowed to connect to ESP8266 TCP server.  <a href="#ga8418023ae67bd83742d7d2642c3d4da0">More...</a><br /></td></tr>
<tr class="separator:ga8418023ae67bd83742d7d2642c3d4da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef6e59fa5bb5d813449d190e2fe66b2e"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gaef6e59fa5bb5d813449d190e2fe66b2e">espconn_tcp_set_max_con_allow</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, uint8 num)</td></tr>
<tr class="memdesc:gaef6e59fa5bb5d813449d190e2fe66b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of TCP clients allowed to connect to ESP8266 TCP server.  <a href="#gaef6e59fa5bb5d813449d190e2fe66b2e">More...</a><br /></td></tr>
<tr class="separator:gaef6e59fa5bb5d813449d190e2fe66b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd79a347f8e665d7b93f31569865b494"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gacd79a347f8e665d7b93f31569865b494">espconn_regist_time</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, uint32 interval, uint8 type_flag)</td></tr>
<tr class="memdesc:gacd79a347f8e665d7b93f31569865b494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register timeout interval of ESP8266 TCP server.  <a href="#gacd79a347f8e665d7b93f31569865b494">More...</a><br /></td></tr>
<tr class="separator:gacd79a347f8e665d7b93f31569865b494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95deabffd3b8a4bec81f91596901f84d"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga95deabffd3b8a4bec81f91596901f84d">espconn_get_connection_info</a> (struct <a class="el" href="structespconn.html">espconn</a> *pespconn, <a class="el" href="struct__remot__info.html">remot_info</a> **pcon_info, uint8 typeflags)</td></tr>
<tr class="memdesc:ga95deabffd3b8a4bec81f91596901f84d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information about a TCP connection or UDP transmission.  <a href="#ga95deabffd3b8a4bec81f91596901f84d">More...</a><br /></td></tr>
<tr class="separator:ga95deabffd3b8a4bec81f91596901f84d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga438ded04b3f8a70948fcf8c551bce179"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga438ded04b3f8a70948fcf8c551bce179">espconn_regist_sentcb</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, espconn_sent_callback sent_cb)</td></tr>
<tr class="memdesc:ga438ded04b3f8a70948fcf8c551bce179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register data sent callback which will be called back when data are successfully sent.  <a href="#ga438ded04b3f8a70948fcf8c551bce179">More...</a><br /></td></tr>
<tr class="separator:ga438ded04b3f8a70948fcf8c551bce179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28cae7c705c8d3da7bb614b6c41c8d1a"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga28cae7c705c8d3da7bb614b6c41c8d1a">espconn_regist_write_finish</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, <a class="el" href="group__Espconn__APIs.html#gac2f5cc499f1d963723ed37d87a029a00">espconn_connect_callback</a> write_finish_fn)</td></tr>
<tr class="memdesc:ga28cae7c705c8d3da7bb614b6c41c8d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a callback which will be called when all sending TCP data is completely write into write-buffer or sent.  <a href="#ga28cae7c705c8d3da7bb614b6c41c8d1a">More...</a><br /></td></tr>
<tr class="separator:ga28cae7c705c8d3da7bb614b6c41c8d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6677ecbe38ce063102e4b7a733829a7f"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga6677ecbe38ce063102e4b7a733829a7f">espconn_send</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, uint8 *psent, uint16 length)</td></tr>
<tr class="memdesc:ga6677ecbe38ce063102e4b7a733829a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data through network.  <a href="#ga6677ecbe38ce063102e4b7a733829a7f">More...</a><br /></td></tr>
<tr class="separator:ga6677ecbe38ce063102e4b7a733829a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga579e4f1c62f7c33be01398931617e988"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga579e4f1c62f7c33be01398931617e988">espconn_sent</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, uint8 *psent, uint16 length)</td></tr>
<tr class="memdesc:ga579e4f1c62f7c33be01398931617e988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send data through network.  <a href="#ga579e4f1c62f7c33be01398931617e988">More...</a><br /></td></tr>
<tr class="separator:ga579e4f1c62f7c33be01398931617e988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62219be0ac7e8dd6085915d5c0777476"><td class="memItemLeft" align="right" valign="top">sint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga62219be0ac7e8dd6085915d5c0777476">espconn_sendto</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, uint8 *psent, uint16 length)</td></tr>
<tr class="memdesc:ga62219be0ac7e8dd6085915d5c0777476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send UDP data.  <a href="#ga62219be0ac7e8dd6085915d5c0777476">More...</a><br /></td></tr>
<tr class="separator:ga62219be0ac7e8dd6085915d5c0777476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233874487e43ccdacf772e47bcd9b976"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga233874487e43ccdacf772e47bcd9b976">espconn_regist_connectcb</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, <a class="el" href="group__Espconn__APIs.html#gac2f5cc499f1d963723ed37d87a029a00">espconn_connect_callback</a> connect_cb)</td></tr>
<tr class="memdesc:ga233874487e43ccdacf772e47bcd9b976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register connection function which will be called back under successful TCP connection.  <a href="#ga233874487e43ccdacf772e47bcd9b976">More...</a><br /></td></tr>
<tr class="separator:ga233874487e43ccdacf772e47bcd9b976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d063a430d96d20b4ea5e28ba41011c"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga56d063a430d96d20b4ea5e28ba41011c">espconn_regist_recvcb</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, <a class="el" href="group__Espconn__APIs.html#ga5c93b1b8d3455a8f4fdeb35b064c4b0f">espconn_recv_callback</a> recv_cb)</td></tr>
<tr class="memdesc:ga56d063a430d96d20b4ea5e28ba41011c"><td class="mdescLeft">&#160;</td><td class="mdescRight">register data receive function which will be called back when data are received.  <a href="#ga56d063a430d96d20b4ea5e28ba41011c">More...</a><br /></td></tr>
<tr class="separator:ga56d063a430d96d20b4ea5e28ba41011c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga771463177734012911e42931a10ee7a2"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga771463177734012911e42931a10ee7a2">espconn_regist_reconcb</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, <a class="el" href="group__Espconn__APIs.html#ga06024aeff44004ddbdb7044b97676bba">espconn_reconnect_callback</a> recon_cb)</td></tr>
<tr class="memdesc:ga771463177734012911e42931a10ee7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register reconnect callback.  <a href="#ga771463177734012911e42931a10ee7a2">More...</a><br /></td></tr>
<tr class="separator:ga771463177734012911e42931a10ee7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43c93f2f0cc14a1c1e95c38e9469b9f"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gaf43c93f2f0cc14a1c1e95c38e9469b9f">espconn_regist_disconcb</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, <a class="el" href="group__Espconn__APIs.html#gac2f5cc499f1d963723ed37d87a029a00">espconn_connect_callback</a> discon_cb)</td></tr>
<tr class="memdesc:gaf43c93f2f0cc14a1c1e95c38e9469b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register disconnection function which will be called back under successful TCP disconnection.  <a href="#gaf43c93f2f0cc14a1c1e95c38e9469b9f">More...</a><br /></td></tr>
<tr class="separator:gaf43c93f2f0cc14a1c1e95c38e9469b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8666579cda9afb8e01dff613326062c0"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga8666579cda9afb8e01dff613326062c0">espconn_port</a> (void)</td></tr>
<tr class="memdesc:ga8666579cda9afb8e01dff613326062c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an available port for network.  <a href="#ga8666579cda9afb8e01dff613326062c0">More...</a><br /></td></tr>
<tr class="separator:ga8666579cda9afb8e01dff613326062c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac76f13b1bd09b3e43beedd50907e0c72"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gac76f13b1bd09b3e43beedd50907e0c72">espconn_set_opt</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, uint8 opt)</td></tr>
<tr class="memdesc:gac76f13b1bd09b3e43beedd50907e0c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set option of TCP connection.  <a href="#gac76f13b1bd09b3e43beedd50907e0c72">More...</a><br /></td></tr>
<tr class="separator:gac76f13b1bd09b3e43beedd50907e0c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8be5ecdee08ca20a2516c4aa289c5e"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga9a8be5ecdee08ca20a2516c4aa289c5e">espconn_clear_opt</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, uint8 opt)</td></tr>
<tr class="memdesc:ga9a8be5ecdee08ca20a2516c4aa289c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear option of TCP connection.  <a href="#ga9a8be5ecdee08ca20a2516c4aa289c5e">More...</a><br /></td></tr>
<tr class="separator:ga9a8be5ecdee08ca20a2516c4aa289c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a78bf74f326d99a2cb498a338da8240"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga0a78bf74f326d99a2cb498a338da8240">espconn_set_keepalive</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, uint8 level, void *optarg)</td></tr>
<tr class="memdesc:ga0a78bf74f326d99a2cb498a338da8240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set configuration of TCP keep alive.  <a href="#ga0a78bf74f326d99a2cb498a338da8240">More...</a><br /></td></tr>
<tr class="separator:ga0a78bf74f326d99a2cb498a338da8240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b470d0af4052d0945ed87ffbf8e684"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gae7b470d0af4052d0945ed87ffbf8e684">espconn_get_keepalive</a> (struct <a class="el" href="structespconn.html">espconn</a> *<a class="el" href="structespconn.html">espconn</a>, uint8 level, void *optarg)</td></tr>
<tr class="memdesc:gae7b470d0af4052d0945ed87ffbf8e684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configuration of TCP keep alive.  <a href="#gae7b470d0af4052d0945ed87ffbf8e684">More...</a><br /></td></tr>
<tr class="separator:gae7b470d0af4052d0945ed87ffbf8e684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34a3074b536dfc09c842b75210cfcdf1"><td class="memItemLeft" align="right" valign="top">err_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga34a3074b536dfc09c842b75210cfcdf1">espconn_gethostbyname</a> (struct <a class="el" href="structespconn.html">espconn</a> *pespconn, const char *hostname, ip_addr_t *addr, <a class="el" href="group__Espconn__APIs.html#gac6c8cf602f9c20d36003dc6d1b518d78">dns_found_callback</a> found)</td></tr>
<tr class="memdesc:ga34a3074b536dfc09c842b75210cfcdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">DNS function.  <a href="#ga34a3074b536dfc09c842b75210cfcdf1">More...</a><br /></td></tr>
<tr class="separator:ga34a3074b536dfc09c842b75210cfcdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7858298be65d5fb385e0614775799292"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga7858298be65d5fb385e0614775799292">espconn_igmp_join</a> (ip_addr_t *host_ip, ip_addr_t *multicast_ip)</td></tr>
<tr class="memdesc:ga7858298be65d5fb385e0614775799292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a multicast group.  <a href="#ga7858298be65d5fb385e0614775799292">More...</a><br /></td></tr>
<tr class="separator:ga7858298be65d5fb385e0614775799292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49a50b6b7007818a45e5aa7eb19eace9"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga49a50b6b7007818a45e5aa7eb19eace9">espconn_igmp_leave</a> (ip_addr_t *host_ip, ip_addr_t *multicast_ip)</td></tr>
<tr class="memdesc:ga49a50b6b7007818a45e5aa7eb19eace9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leave a multicast group.  <a href="#ga49a50b6b7007818a45e5aa7eb19eace9">More...</a><br /></td></tr>
<tr class="separator:ga49a50b6b7007818a45e5aa7eb19eace9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2193ea6779889bef71dc6d368c6b8f80"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#ga2193ea6779889bef71dc6d368c6b8f80">espconn_recv_hold</a> (struct <a class="el" href="structespconn.html">espconn</a> *pespconn)</td></tr>
<tr class="memdesc:ga2193ea6779889bef71dc6d368c6b8f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts in a request to block the TCP receive function.  <a href="#ga2193ea6779889bef71dc6d368c6b8f80">More...</a><br /></td></tr>
<tr class="separator:ga2193ea6779889bef71dc6d368c6b8f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac409e8c250ee409985475f5c7fa02950"><td class="memItemLeft" align="right" valign="top">sint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gac409e8c250ee409985475f5c7fa02950">espconn_recv_unhold</a> (struct <a class="el" href="structespconn.html">espconn</a> *pespconn)</td></tr>
<tr class="memdesc:gac409e8c250ee409985475f5c7fa02950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unblock TCP receiving data (i.e. undo espconn_recv_hold).  <a href="#gac409e8c250ee409985475f5c7fa02950">More...</a><br /></td></tr>
<tr class="separator:gac409e8c250ee409985475f5c7fa02950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc578b3f5f5701f2a140683a4524ff0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Espconn__APIs.html#gabc578b3f5f5701f2a140683a4524ff0a">espconn_dns_setserver</a> (char numdns, ip_addr_t *dnsserver)</td></tr>
<tr class="memdesc:gabc578b3f5f5701f2a140683a4524ff0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set default DNS server. Two DNS server is allowed to be set.  <a href="#gabc578b3f5f5701f2a140683a4524ff0a">More...</a><br /></td></tr>
<tr class="separator:gabc578b3f5f5701f2a140683a4524ff0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Network espconn APIs. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga0bf23d2d937c693c7d9a66ac609194bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_ABRT&#160;&#160;&#160;-8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connection aborted. </p>

</div>
</div>
<a class="anchor" id="ga0ab82f63b7e43bf6ea1c36653707b67d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_ARG&#160;&#160;&#160;-12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Illegal argument. </p>

</div>
</div>
<a class="anchor" id="ga867f470db66f9ba20f7ea9a494fe6320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_CLSD&#160;&#160;&#160;-10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connection closed. </p>

</div>
</div>
<a class="anchor" id="ga39113d279962242d9ed0aaba5fc57c46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_CONN&#160;&#160;&#160;-11</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not connected. </p>

</div>
</div>
<a class="anchor" id="ga4abb7c01f3e8465771f76aba5071c1fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_IF&#160;&#160;&#160;-14</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>UDP send error. </p>

</div>
</div>
<a class="anchor" id="gab2d9a86577de714e72eb79e757b6e6d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_INPROGRESS&#160;&#160;&#160;-5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operation in progress. </p>

</div>
</div>
<a class="anchor" id="gadbb6b13a82c7a627b13faf308fe38981"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_ISCONN&#160;&#160;&#160;-15</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Already connected. </p>

</div>
</div>
<a class="anchor" id="ga35b472e2b51197621984908dfe3a0984"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_MAXNUM&#160;&#160;&#160;-7</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Total number exceeds the maximum limitation. </p>

</div>
</div>
<a class="anchor" id="ga45549b79bd5d005eaeabd547f9c9b8d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_MEM&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Out of memory. </p>

</div>
</div>
<a class="anchor" id="ga0149e7f6afdf2a5aef57e1fbe19c0b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_OK&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No error, everything OK. </p>

</div>
</div>
<a class="anchor" id="ga2bae98a46863135cfb79a5296b41d058"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_RST&#160;&#160;&#160;-9</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connection reset. </p>

</div>
</div>
<a class="anchor" id="ga22ce1e3a32571dd2ec6d755a77ac976c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_RTE&#160;&#160;&#160;-4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Routing problem. </p>

</div>
</div>
<a class="anchor" id="ga444a33b46763426495ef6445427301f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ESPCONN_TIMEOUT&#160;&#160;&#160;-3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timeout. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gac6c8cf602f9c20d36003dc6d1b518d78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* dns_found_callback) (const char *name, ip_addr_t *ipaddr, void *callback_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback which is invoked when a hostname is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>char *name : hostname </td></tr>
    <tr><td class="paramname">ip_addr_t</td><td>*ipaddr : IP address of the hostname, or to be NULL if the name could not be found (or on any other error). </td></tr>
    <tr><td class="paramname">void</td><td>*callback_arg : callback argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="gac2f5cc499f1d963723ed37d87a029a00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  espconn_connect_callback) (void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect callback. </p>
<p>Callback which will be called if successful listening (ESP8266 as TCP server) or connection (ESP8266 as TCP client) callback, register by espconn_regist_connectcb.</p>
<dl class="section attention"><dt>Attention</dt><dd>The pointer "void *arg" may be different in different callbacks, please don't use this pointer directly to distinguish one from another in multiple connections, use remote_ip and remote_port in espconn instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">void</td><td>*arg : pointer corresponding structure espconn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga06024aeff44004ddbdb7044b97676bba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  espconn_reconnect_callback) (void *arg, sint8 err)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconnect callback. </p>
<p>Enter this callback when error occurred, TCP connection broke. This callback is registered by espconn_regist_reconcb.</p>
<dl class="section attention"><dt>Attention</dt><dd>The pointer "void *arg" may be different in different callbacks, please don't use this pointer directly to distinguish one from another in multiple connections, use remote_ip and remote_port in espconn instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">void</td><td>*arg : pointer corresponding structure espconn. </td></tr>
    <tr><td class="paramname">sint8</td><td>err : error code<ul>
<li>ESCONN_TIMEOUT - Timeout</li>
<li>ESPCONN_ABRT - TCP connection aborted</li>
<li>ESPCONN_RST - TCP connection abort</li>
<li>ESPCONN_CLSD - TCP connection closed</li>
<li>ESPCONN_CONN - TCP connection</li>
<li>ESPCONN_HANDSHAKE - TCP SSL handshake fail</li>
<li>ESPCONN_PROTO_MSG - SSL application invalid</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga5c93b1b8d3455a8f4fdeb35b064c4b0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*  espconn_recv_callback) (void *arg, char *pdata, unsigned short len)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A callback prototype to inform about events for a espconn </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaaae7451fb36d445e625d52b3f0eec36e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Espconn__APIs.html#gaaae7451fb36d445e625d52b3f0eec36e">espconn_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaaae7451fb36d445e625d52b3f0eec36ea858f5c8ad925f16f59eb728619235e8b"></a>ESPCONN_KEEPIDLE&#160;</td><td class="fielddoc">
<p>TCP keep-alive interval, unit : second. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaaae7451fb36d445e625d52b3f0eec36ea9266ad9351007ce73e8877405970a6d8"></a>ESPCONN_KEEPINTVL&#160;</td><td class="fielddoc">
<p>packet interval during TCP keep-alive, unit : second. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaaae7451fb36d445e625d52b3f0eec36ea1e723b94b0ac601545a717261203eb1b"></a>ESPCONN_KEEPCNT&#160;</td><td class="fielddoc">
<p>maximum packet retry count of TCP keep-alive. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga9db40198a52a9becd150a851f9855a92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Espconn__APIs.html#ga9db40198a52a9becd150a851f9855a92">espconn_option</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga9db40198a52a9becd150a851f9855a92a9cb44b08d9f53701b054b08d04f7d71f"></a>ESPCONN_START&#160;</td><td class="fielddoc">
<p>no option, start enum. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9db40198a52a9becd150a851f9855a92a8c4b05b4bdbd12c64f1809c48d99e395"></a>ESPCONN_REUSEADDR&#160;</td><td class="fielddoc">
<p>free memory after TCP disconnection happen, need not wait 2 minutes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9db40198a52a9becd150a851f9855a92a22a60c5e343e19f83f9facedc8cd6f89"></a>ESPCONN_NODELAY&#160;</td><td class="fielddoc">
<p>disable nagle algorithm during TCP data transmission, quicken the data transmission. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9db40198a52a9becd150a851f9855a92a5a42c1ab1c6a9e2cce272046bce29687"></a>ESPCONN_COPY&#160;</td><td class="fielddoc">
<p>enable espconn_regist_write_finish, enter write_finish_callback means that the data espconn_send sending was written into 2920 bytes write-buffer waiting for sending or already sent. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9db40198a52a9becd150a851f9855a92a131641817461609c89b8086dd90f64a9"></a>ESPCONN_KEEPALIVE&#160;</td><td class="fielddoc">
<p>enable TCP keep alive. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga9db40198a52a9becd150a851f9855a92ae2ad46665b977365b8cc24f2b325155f"></a>ESPCONN_END&#160;</td><td class="fielddoc">
<p>no option, end enum. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga27ebed6341108494ecf41ec8a7d37c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Espconn__APIs.html#ga27ebed6341108494ecf41ec8a7d37c4b">espconn_state</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Current state of the espconn. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga27ebed6341108494ecf41ec8a7d37c4ba7dd74b008ab5d04f15ff84de4b70bf90"></a>ESPCONN_NONE&#160;</td><td class="fielddoc">
<p>idle state, no connection </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga27ebed6341108494ecf41ec8a7d37c4baa13c91321f9aef1bf5023f1ea18e093a"></a>ESPCONN_WAIT&#160;</td><td class="fielddoc">
<p>ESP8266 is as TCP client, and waiting for connection </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga27ebed6341108494ecf41ec8a7d37c4ba97c2f022ffce819bc2658f4e5796543a"></a>ESPCONN_LISTEN&#160;</td><td class="fielddoc">
<p>ESP8266 is as TCP server, and waiting for connection </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga27ebed6341108494ecf41ec8a7d37c4ba2581f4215688fddcb1852ea4cbbcdaef"></a>ESPCONN_CONNECT&#160;</td><td class="fielddoc">
<p>connected </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga27ebed6341108494ecf41ec8a7d37c4bab7b47f073e3e6db0ce792ab8fff1df02"></a>ESPCONN_WRITE&#160;</td><td class="fielddoc">
<p>sending data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga27ebed6341108494ecf41ec8a7d37c4ba01caf55e6b01ffa1089348102d42734c"></a>ESPCONN_READ&#160;</td><td class="fielddoc">
<p>receiving data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga27ebed6341108494ecf41ec8a7d37c4ba755ebf5af367126c8c2c33f8e919bac4"></a>ESPCONN_CLOSE&#160;</td><td class="fielddoc">
<p>connection closed </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga822c96862e04f46aff8d65cb8170b60f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__Espconn__APIs.html#ga822c96862e04f46aff8d65cb8170b60f">espconn_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Protocol family and type of the espconn </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga822c96862e04f46aff8d65cb8170b60faf10957d87831780be73e55426e8da737"></a>ESPCONN_INVALID&#160;</td><td class="fielddoc">
<p>invalid type </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga822c96862e04f46aff8d65cb8170b60faf9113ca7b14a1637d2a0099367622879"></a>ESPCONN_TCP&#160;</td><td class="fielddoc">
<p>TCP </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga822c96862e04f46aff8d65cb8170b60fa85d8592fc339ccda13561161ddfd63f7"></a>ESPCONN_UDP&#160;</td><td class="fielddoc">
<p>UDP </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gabd44446e3fc4a61fdef77d473deb678b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_accept </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a TCP server (i.e. accepts connections). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network connection structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_MEM - Out of memory</li>
<li>ESPCONN_ISCONN - Already connected</li>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9a8be5ecdee08ca20a2516c4aa289c5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_clear_opt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear option of TCP connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP connection structure </td></tr>
    <tr><td class="paramname">uint8</td><td>opt : enum espconn_option</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga949cd618667cea85b1b99d14b90dce7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Connect to a TCP server (ESP8266 acting as TCP client). </p>
<dl class="section attention"><dt>Attention</dt><dd>If espconn_connect fail, returns non-0 value, there is no connection, so it won't enter any espconn callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network connection structure, the espconn to listen to the connection</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_RTE - Routing Problem</li>
<li>ESPCONN_MEM - Out of memory</li>
<li>ESPCONN_ISCONN - Already connected</li>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad55b9729c7629f40c8e7ae2d73f7f174"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create UDP transmission. </p>
<dl class="section attention"><dt>Attention</dt><dd>Parameter remote_ip and remote_port need to be set, do not set to be 0.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the UDP control block structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_MEM - Out of memory</li>
<li>ESPCONN_ISCONN - Already connected</li>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding UDP transmission according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga63d15dda14dfcd8da278c31f048910c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_delete </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a transmission. </p>
<dl class="section attention"><dt>Attention</dt><dd>Corresponding creation API :<ul>
<li>TCP: espconn_accept,</li>
<li>UDP: espconn_create</li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network connection structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding network according to structure espconn</li>
<li>ESPCONN_INPROGRESS - the connection is still in progress, please call espconn_disconnect to disconnect before delete it. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga9969873c3b8ee86a34496a5166cf8bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_disconnect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disconnect a TCP connection. </p>
<dl class="section attention"><dt>Attention</dt><dd>Don't call this API in any espconn callback. If needed, please use system task to trigger espconn_disconnect.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network connection structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gabc578b3f5f5701f2a140683a4524ff0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void espconn_dns_setserver </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>numdns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ip_addr_t *&#160;</td>
          <td class="paramname"><em>dnsserver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set default DNS server. Two DNS server is allowed to be set. </p>
<dl class="section attention"><dt>Attention</dt><dd>Only if ESP8266 DHCP client is disabled (wifi_station_dhcpc_stop), this API can be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">char</td><td>numdns : DNS server ID, 0 or 1 </td></tr>
    <tr><td class="paramname">ip_addr_t</td><td>*dnsserver : DNS server IP</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga95deabffd3b8a4bec81f91596901f84d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_get_connection_info </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>pespconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__remot__info.html">remot_info</a> **&#160;</td>
          <td class="paramname"><em>pcon_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>typeflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the information about a TCP connection or UDP transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network connection structure </td></tr>
    <tr><td class="paramname">remot_info</td><td>**pcon_info : connect to client info </td></tr>
    <tr><td class="paramname">uint8</td><td>typeflags : 0, regular server; 1, ssl server</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding transmission according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae7b470d0af4052d0945ed87ffbf8e684"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_get_keepalive </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get configuration of TCP keep alive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP connection structure </td></tr>
    <tr><td class="paramname">uint8</td><td>level : enum espconn_level </td></tr>
    <tr><td class="paramname">void*</td><td>optarg : value of parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga34a3074b536dfc09c842b75210cfcdf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">err_t espconn_gethostbyname </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>pespconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ip_addr_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Espconn__APIs.html#gac6c8cf602f9c20d36003dc6d1b518d78">dns_found_callback</a>&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DNS function. </p>
<p>Parse a hostname (string) to an IP address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *pespconn : espconn to parse a hostname. </td></tr>
    <tr><td class="paramname">const</td><td>char *hostname : the hostname. </td></tr>
    <tr><td class="paramname">ip_addr_t</td><td>*addr : IP address. </td></tr>
    <tr><td class="paramname">dns_found_callback</td><td>found : callback of DNS</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>err_t :<ul>
<li>ESPCONN_OK - succeed</li>
<li>ESPCONN_INPROGRESS - error code : already connected</li>
<li>ESPCONN_ARG - error code : illegal argument, can't find network transmission according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7858298be65d5fb385e0614775799292"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_igmp_join </td>
          <td>(</td>
          <td class="paramtype">ip_addr_t *&#160;</td>
          <td class="paramname"><em>host_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ip_addr_t *&#160;</td>
          <td class="paramname"><em>multicast_ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a multicast group. </p>
<dl class="section attention"><dt>Attention</dt><dd>This API can only be called after the ESP8266 station connects to a router.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_addr_t</td><td>*host_ip : IP of UDP host </td></tr>
    <tr><td class="paramname">ip_addr_t</td><td>*multicast_ip : IP of multicast group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_MEM - Out of memory </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga49a50b6b7007818a45e5aa7eb19eace9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_igmp_leave </td>
          <td>(</td>
          <td class="paramtype">ip_addr_t *&#160;</td>
          <td class="paramname"><em>host_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ip_addr_t *&#160;</td>
          <td class="paramname"><em>multicast_ip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Leave a multicast group. </p>
<dl class="section attention"><dt>Attention</dt><dd>This API can only be called after the ESP8266 station connects to a router.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip_addr_t</td><td>*host_ip : IP of UDP host </td></tr>
    <tr><td class="paramname">ip_addr_t</td><td>*multicast_ip : IP of multicast group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_MEM - Out of memory </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab1bd524be2b4c1b727e3519e3cae69bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void espconn_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>espconn initialization. </p>
<dl class="section attention"><dt>Attention</dt><dd>Please call this API in user_init, if you need to use espconn functions.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga8666579cda9afb8e01dff613326062c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 espconn_port </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an available port for network. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Port number. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2193ea6779889bef71dc6d368c6b8f80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_recv_hold </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>pespconn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts in a request to block the TCP receive function. </p>
<dl class="section attention"><dt>Attention</dt><dd>The function does not act immediately; we recommend calling it while reserving 5*1460 bytes of memory. This API can be called more than once.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : corresponding TCP connection structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac409e8c250ee409985475f5c7fa02950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_recv_unhold </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>pespconn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unblock TCP receiving data (i.e. undo espconn_recv_hold). </p>
<dl class="section attention"><dt>Attention</dt><dd>This API takes effect immediately.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : corresponding TCP connection structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga233874487e43ccdacf772e47bcd9b976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_regist_connectcb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Espconn__APIs.html#gac2f5cc499f1d963723ed37d87a029a00">espconn_connect_callback</a>&#160;</td>
          <td class="paramname"><em>connect_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register connection function which will be called back under successful TCP connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP connection structure </td></tr>
    <tr><td class="paramname">espconn_connect_callback</td><td>connect_cb : registered callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaf43c93f2f0cc14a1c1e95c38e9469b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_regist_disconcb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Espconn__APIs.html#gac2f5cc499f1d963723ed37d87a029a00">espconn_connect_callback</a>&#160;</td>
          <td class="paramname"><em>discon_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register disconnection function which will be called back under successful TCP disconnection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP connection structure </td></tr>
    <tr><td class="paramname">espconn_connect_callback</td><td>discon_cb : registered callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga771463177734012911e42931a10ee7a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_regist_reconcb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Espconn__APIs.html#ga06024aeff44004ddbdb7044b97676bba">espconn_reconnect_callback</a>&#160;</td>
          <td class="paramname"><em>recon_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register reconnect callback. </p>
<dl class="section attention"><dt>Attention</dt><dd>espconn_reconnect_callback is more like a network-broken error handler; it handles errors that occurs in any phase of the connection. For instance, if espconn_send fails, espconn_reconnect_callback will be called because the network is broken.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP connection structure </td></tr>
    <tr><td class="paramname">espconn_reconnect_callback</td><td>recon_cb : registered callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga56d063a430d96d20b4ea5e28ba41011c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_regist_recvcb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Espconn__APIs.html#ga5c93b1b8d3455a8f4fdeb35b064c4b0f">espconn_recv_callback</a>&#160;</td>
          <td class="paramname"><em>recv_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register data receive function which will be called back when data are received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network transmission structure </td></tr>
    <tr><td class="paramname">espconn_recv_callback</td><td>recv_cb : registered callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga438ded04b3f8a70948fcf8c551bce179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_regist_sentcb </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">espconn_sent_callback&#160;</td>
          <td class="paramname"><em>sent_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register data sent callback which will be called back when data are successfully sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network connection structure </td></tr>
    <tr><td class="paramname">espconn_sent_callback</td><td>sent_cb : registered callback function which will be called if the data is successfully sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding transmission according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gacd79a347f8e665d7b93f31569865b494"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_regist_time </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>type_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register timeout interval of ESP8266 TCP server. </p>
<dl class="section attention"><dt>Attention</dt><dd>1. If timeout is set to 0, timeout will be disable and ESP8266 TCP server will not disconnect TCP clients has stopped communication. This usage of timeout=0, is deprecated. </dd>
<dd>
2. This timeout interval is not very precise, only as reference.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP connection structure </td></tr>
    <tr><td class="paramname">uint32</td><td>interval : timeout interval, unit: second, maximum: 7200 seconds </td></tr>
    <tr><td class="paramname">uint8</td><td>type_flag : 0, set for all connections; 1, set for a specific connection<ul>
<li>If the type_flag set to be 0, please call this API after espconn_accept, before listened a TCP connection.</li>
<li>If the type_flag set to be 1, the first parameter *espconn is the specific connection.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga28cae7c705c8d3da7bb614b6c41c8d1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_regist_write_finish </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Espconn__APIs.html#gac2f5cc499f1d963723ed37d87a029a00">espconn_connect_callback</a>&#160;</td>
          <td class="paramname"><em>write_finish_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a callback which will be called when all sending TCP data is completely write into write-buffer or sent. </p>
<p>Need to call espconn_set_opt to enable write-buffer first.</p>
<dl class="section attention"><dt>Attention</dt><dd>1. write-buffer is used to keep TCP data that waiting to be sent, queue number of the write-buffer is 8 which means that it can keep 8 packets at most. The size of write-buffer is 2920 bytes. </dd>
<dd>
2. Users can enable it by using espconn_set_opt. </dd>
<dd>
3. Users can call espconn_send to send the next packet in write_finish_callback instead of using espconn_sent_callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network connection structure </td></tr>
    <tr><td class="paramname">espconn_connect_callback</td><td>write_finish_fn : registered callback function which will be called if the data is completely write into write buffer or sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6677ecbe38ce063102e4b7a733829a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_send </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>psent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data through network. </p>
<dl class="section attention"><dt>Attention</dt><dd>1. Please call espconn_send after espconn_sent_callback of the pre-packet. </dd>
<dd>
2. If it is a UDP transmission, it is suggested to set espconn-&gt;proto.udp-&gt;remote_ip and remote_port before every calling of espconn_send.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network connection structure </td></tr>
    <tr><td class="paramname">uint8</td><td>*psent : pointer of data </td></tr>
    <tr><td class="paramname">uint16</td><td>length : data length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_MEM - Out of memory</li>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding network transmission according to structure espconn</li>
<li>ESPCONN_MAXNUM - buffer of sending data is full</li>
<li>ESPCONN_IF - send UDP data fail </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga62219be0ac7e8dd6085915d5c0777476"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint16 espconn_sendto </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>psent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send UDP data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the UDP structure </td></tr>
    <tr><td class="paramname">uint8</td><td>*psent : pointer of data </td></tr>
    <tr><td class="paramname">uint16</td><td>length : data length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_MEM - Out of memory</li>
<li>ESPCONN_MAXNUM - buffer of sending data is full</li>
<li>ESPCONN_IF - send UDP data fail </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga579e4f1c62f7c33be01398931617e988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_sent </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8 *&#160;</td>
          <td class="paramname"><em>psent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send data through network. </p>
<p>This API is deprecated, please use espconn_send instead.</p>
<dl class="section attention"><dt>Attention</dt><dd>1. Please call espconn_sent after espconn_sent_callback of the pre-packet. </dd>
<dd>
2. If it is a UDP transmission, it is suggested to set espconn-&gt;proto.udp-&gt;remote_ip and remote_port before every calling of espconn_sent.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the network connection structure </td></tr>
    <tr><td class="paramname">uint8</td><td>*psent : pointer of data </td></tr>
    <tr><td class="paramname">uint16</td><td>length : data length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_MEM - Out of memory</li>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding network transmission according to structure espconn</li>
<li>ESPCONN_MAXNUM - buffer of sending data is full</li>
<li>ESPCONN_IF - send UDP data fail </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga0a78bf74f326d99a2cb498a338da8240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_set_keepalive </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>optarg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set configuration of TCP keep alive. </p>
<dl class="section attention"><dt>Attention</dt><dd>In general, we need not call this API. If needed, please call it in espconn_connect_callback and call espconn_set_opt to enable keep alive first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP connection structure </td></tr>
    <tr><td class="paramname">uint8</td><td>level : To do TCP keep-alive detection every ESPCONN_KEEPIDLE. If there is no response, retry ESPCONN_KEEPCNT times every ESPCONN_KEEPINTVL. If still no response, considers it as TCP connection broke, goes into espconn_reconnect_callback. Notice, keep alive interval is not precise, only for reference, it depends on priority. </td></tr>
    <tr><td class="paramname">void*</td><td>optarg : value of parameter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac76f13b1bd09b3e43beedd50907e0c72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_set_opt </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set option of TCP connection. </p>
<dl class="section attention"><dt>Attention</dt><dd>In general, we need not call this API. If call espconn_set_opt, please call it in espconn_connect_callback.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP connection structure </td></tr>
    <tr><td class="paramname">uint8</td><td>opt : option of TCP connection, refer to enum espconn_option<ul>
<li>bit 0: 1: free memory after TCP disconnection happen need not wait 2 minutes;</li>
<li>bit 1: 1: disable nagle algorithm during TCP data transmission, quiken the data transmission.</li>
<li>bit 2: 1: enable espconn_regist_write_finish, enter write finish callback means the data espconn_send sending was written into 2920 bytes write-buffer waiting for sending or already sent.</li>
<li>bit 3: 1: enable TCP keep alive</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaa7665768ea19f95957284938cc0af950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 espconn_tcp_get_max_con </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get maximum number of how many TCP connections are allowed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum number of how many TCP connections are allowed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8418023ae67bd83742d7d2642c3d4da0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_tcp_get_max_con_allow </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum number of TCP clients which are allowed to connect to ESP8266 TCP server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP server structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6281d28b05672dc10f702f0e5386fb98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_tcp_set_max_con </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of how many TCP connection is allowed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint8</td><td>num : Maximum number of how many TCP connection is allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gaef6e59fa5bb5d813449d190e2fe66b2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sint8 espconn_tcp_set_max_con_allow </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structespconn.html">espconn</a> *&#160;</td>
          <td class="paramname"><em>espconn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of TCP clients allowed to connect to ESP8266 TCP server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">struct</td><td>espconn *espconn : the TCP server structure </td></tr>
    <tr><td class="paramname">uint8</td><td>num : Maximum number of TCP clients which are allowed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 : succeed </dd>
<dd>
Non-0 : error code<ul>
<li>ESPCONN_ARG - illegal argument, can't find the corresponding TCP connection according to structure espconn </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 1 2016 10:19:26 for ESP8266_RTOS_SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

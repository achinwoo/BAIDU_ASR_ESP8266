<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>ESP8266_RTOS_SDK: System APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESP8266_RTOS_SDK
   &#160;<span id="projectnumber">v1.4.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">System APIs</div>  </div>
</div><!--header-->
<div class="contents">

<p>System APIs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__System__boot__APIs"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__boot__APIs.html">Boot APIs</a></td></tr>
<tr class="memdesc:group__System__boot__APIs"><td class="mdescLeft">&#160;</td><td class="mdescRight">boot APIs <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__Upgrade__APIs"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Upgrade__APIs.html">Upgrade APIs</a></td></tr>
<tr class="memdesc:group__Upgrade__APIs"><td class="mdescLeft">&#160;</td><td class="mdescRight">Firmware upgrade (FOTA) APIs. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrst__info.html">rst_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf560461b4a37405f75fd789165f6c576"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#gaf560461b4a37405f75fd789165f6c576">rst_reason</a> { <br />
&#160;&#160;<a class="el" href="group__System__APIs.html#ggaf560461b4a37405f75fd789165f6c576af39e71277c3bfc84b75a4a5683531565">REASON_DEFAULT_RST</a> = 0, 
<a class="el" href="group__System__APIs.html#ggaf560461b4a37405f75fd789165f6c576a90f8f58c2fec687ee00f4735bf24006d">REASON_WDT_RST</a>, 
<a class="el" href="group__System__APIs.html#ggaf560461b4a37405f75fd789165f6c576a37032d096425911146ce105004cc8adb">REASON_EXCEPTION_RST</a>, 
<a class="el" href="group__System__APIs.html#ggaf560461b4a37405f75fd789165f6c576a57184a4fb4d760f85fd0834566bf6e9c">REASON_SOFT_WDT_RST</a>, 
<br />
&#160;&#160;<a class="el" href="group__System__APIs.html#ggaf560461b4a37405f75fd789165f6c576a6d052f0a22d1b1d060a7e017f6152559">REASON_SOFT_RESTART</a>, 
<a class="el" href="group__System__APIs.html#ggaf560461b4a37405f75fd789165f6c576acee6519d545f6be1bac3e00be8637ee7">REASON_DEEP_SLEEP_AWAKE</a>, 
<a class="el" href="group__System__APIs.html#ggaf560461b4a37405f75fd789165f6c576a9ab5cbcccb384a176990019a8e1b2cc8">REASON_EXT_SYS_RST</a>
<br />
 }<tr class="separator:gaf560461b4a37405f75fd789165f6c576"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9f0263b1c227015248c7020e41d787b9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrst__info.html">rst_info</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga9f0263b1c227015248c7020e41d787b9">system_get_rst_info</a> (void)</td></tr>
<tr class="memdesc:ga9f0263b1c227015248c7020e41d787b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reason of restart.  <a href="#ga9f0263b1c227015248c7020e41d787b9">More...</a><br /></td></tr>
<tr class="separator:ga9f0263b1c227015248c7020e41d787b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82dfc665528462dbaa945e45512b8c93"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga82dfc665528462dbaa945e45512b8c93">system_get_sdk_version</a> (void)</td></tr>
<tr class="memdesc:ga82dfc665528462dbaa945e45512b8c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get information of the SDK version.  <a href="#ga82dfc665528462dbaa945e45512b8c93">More...</a><br /></td></tr>
<tr class="separator:ga82dfc665528462dbaa945e45512b8c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae04bb6e4dba5ca53c4f5af629c235bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#gae04bb6e4dba5ca53c4f5af629c235bec">system_restore</a> (void)</td></tr>
<tr class="memdesc:gae04bb6e4dba5ca53c4f5af629c235bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to default settings.  <a href="#gae04bb6e4dba5ca53c4f5af629c235bec">More...</a><br /></td></tr>
<tr class="separator:gae04bb6e4dba5ca53c4f5af629c235bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80e0119dbfcaaa43025fe2135d3d1efc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga80e0119dbfcaaa43025fe2135d3d1efc">system_restart</a> (void)</td></tr>
<tr class="memdesc:ga80e0119dbfcaaa43025fe2135d3d1efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart system.  <a href="#ga80e0119dbfcaaa43025fe2135d3d1efc">More...</a><br /></td></tr>
<tr class="separator:ga80e0119dbfcaaa43025fe2135d3d1efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2d62411a8baa3b7fec777d281397e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga2b2d62411a8baa3b7fec777d281397e1">system_deep_sleep</a> (uint32 time_in_us)</td></tr>
<tr class="memdesc:ga2b2d62411a8baa3b7fec777d281397e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the chip to deep-sleep mode.  <a href="#ga2b2d62411a8baa3b7fec777d281397e1">More...</a><br /></td></tr>
<tr class="separator:ga2b2d62411a8baa3b7fec777d281397e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf7c29067d92bf6c03747b4ad2c2bf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#gaaaf7c29067d92bf6c03747b4ad2c2bf6">system_deep_sleep_set_option</a> (uint8 option)</td></tr>
<tr class="memdesc:gaaaf7c29067d92bf6c03747b4ad2c2bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this API before system_deep_sleep to set the activity after the next deep-sleep wakeup.  <a href="#gaaaf7c29067d92bf6c03747b4ad2c2bf6">More...</a><br /></td></tr>
<tr class="separator:gaaaf7c29067d92bf6c03747b4ad2c2bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff40fbcef002e346e8f36c378cf75d86"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#gaff40fbcef002e346e8f36c378cf75d86">system_get_time</a> (void)</td></tr>
<tr class="memdesc:gaff40fbcef002e346e8f36c378cf75d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get system time, unit: microsecond.  <a href="#gaff40fbcef002e346e8f36c378cf75d86">More...</a><br /></td></tr>
<tr class="separator:gaff40fbcef002e346e8f36c378cf75d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3103885b6ff682cac77fea78c2b73425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga3103885b6ff682cac77fea78c2b73425">system_print_meminfo</a> (void)</td></tr>
<tr class="memdesc:ga3103885b6ff682cac77fea78c2b73425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the system memory distribution, including data/rodata/bss/heap.  <a href="#ga3103885b6ff682cac77fea78c2b73425">More...</a><br /></td></tr>
<tr class="separator:ga3103885b6ff682cac77fea78c2b73425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258edd68184bb78f062a3b375dca997c"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga258edd68184bb78f062a3b375dca997c">system_get_free_heap_size</a> (void)</td></tr>
<tr class="memdesc:ga258edd68184bb78f062a3b375dca997c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of available heap.  <a href="#ga258edd68184bb78f062a3b375dca997c">More...</a><br /></td></tr>
<tr class="separator:ga258edd68184bb78f062a3b375dca997c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86228f8d572c91ec871684121dad0647"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga86228f8d572c91ec871684121dad0647">system_get_chip_id</a> (void)</td></tr>
<tr class="memdesc:ga86228f8d572c91ec871684121dad0647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the chip ID.  <a href="#ga86228f8d572c91ec871684121dad0647">More...</a><br /></td></tr>
<tr class="separator:ga86228f8d572c91ec871684121dad0647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53909af3917e5dafc57c5a4d75e6ca2a"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga53909af3917e5dafc57c5a4d75e6ca2a">system_rtc_clock_cali_proc</a> (void)</td></tr>
<tr class="memdesc:ga53909af3917e5dafc57c5a4d75e6ca2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RTC clock cycle.  <a href="#ga53909af3917e5dafc57c5a4d75e6ca2a">More...</a><br /></td></tr>
<tr class="separator:ga53909af3917e5dafc57c5a4d75e6ca2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff1e2f744888e01d75bbb1cb2fdee0cb"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#gaff1e2f744888e01d75bbb1cb2fdee0cb">system_get_rtc_time</a> (void)</td></tr>
<tr class="memdesc:gaff1e2f744888e01d75bbb1cb2fdee0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get RTC time, unit: RTC clock cycle.  <a href="#gaff1e2f744888e01d75bbb1cb2fdee0cb">More...</a><br /></td></tr>
<tr class="separator:gaff1e2f744888e01d75bbb1cb2fdee0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac89e6906018b3f4ccd1ba4059f344d5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#gac89e6906018b3f4ccd1ba4059f344d5e">system_rtc_mem_read</a> (uint8 src, void *dst, uint16 n)</td></tr>
<tr class="memdesc:gac89e6906018b3f4ccd1ba4059f344d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read user data from the RTC memory.  <a href="#gac89e6906018b3f4ccd1ba4059f344d5e">More...</a><br /></td></tr>
<tr class="separator:gac89e6906018b3f4ccd1ba4059f344d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga669af802153a408dbf9b8b34697e34e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga669af802153a408dbf9b8b34697e34e2">system_rtc_mem_write</a> (uint8 dst, const void *src, uint16 n)</td></tr>
<tr class="memdesc:ga669af802153a408dbf9b8b34697e34e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write user data to the RTC memory.  <a href="#ga669af802153a408dbf9b8b34697e34e2">More...</a><br /></td></tr>
<tr class="separator:ga669af802153a408dbf9b8b34697e34e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc697cba1894da7a66d8816ec590682"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga6fc697cba1894da7a66d8816ec590682">system_uart_swap</a> (void)</td></tr>
<tr class="memdesc:ga6fc697cba1894da7a66d8816ec590682"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART0 swap.  <a href="#ga6fc697cba1894da7a66d8816ec590682">More...</a><br /></td></tr>
<tr class="separator:ga6fc697cba1894da7a66d8816ec590682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fe928c2d760669eaa7928b6e00c615c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga2fe928c2d760669eaa7928b6e00c615c">system_uart_de_swap</a> (void)</td></tr>
<tr class="memdesc:ga2fe928c2d760669eaa7928b6e00c615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable UART0 swap.  <a href="#ga2fe928c2d760669eaa7928b6e00c615c">More...</a><br /></td></tr>
<tr class="separator:ga2fe928c2d760669eaa7928b6e00c615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b49ed94048da366d384364482c5ae43"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga3b49ed94048da366d384364482c5ae43">system_adc_read</a> (void)</td></tr>
<tr class="memdesc:ga3b49ed94048da366d384364482c5ae43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the input voltage of TOUT pin 6, unit : 1/1024 V.  <a href="#ga3b49ed94048da366d384364482c5ae43">More...</a><br /></td></tr>
<tr class="separator:ga3b49ed94048da366d384364482c5ae43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1baad08cac941b54b44126045e38cc"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#gacf1baad08cac941b54b44126045e38cc">system_get_vdd33</a> (void)</td></tr>
<tr class="memdesc:gacf1baad08cac941b54b44126045e38cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the power voltage of VDD3P3 pin 3 and 4, unit : 1/1024 V.  <a href="#gacf1baad08cac941b54b44126045e38cc">More...</a><br /></td></tr>
<tr class="separator:gacf1baad08cac941b54b44126045e38cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68a7b6345630e42fde3e827108571e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#gae68a7b6345630e42fde3e827108571e0">system_param_save_with_protect</a> (uint16 start_sec, void *param, uint16 len)</td></tr>
<tr class="memdesc:gae68a7b6345630e42fde3e827108571e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into flash with protection.  <a href="#gae68a7b6345630e42fde3e827108571e0">More...</a><br /></td></tr>
<tr class="separator:gae68a7b6345630e42fde3e827108571e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga753aade115708d360f25bff422ef1f55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga753aade115708d360f25bff422ef1f55">system_param_load</a> (uint16 start_sec, uint16 offset, void *param, uint16 len)</td></tr>
<tr class="memdesc:ga753aade115708d360f25bff422ef1f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data saved into flash with the read/write protection.  <a href="#ga753aade115708d360f25bff422ef1f55">More...</a><br /></td></tr>
<tr class="separator:ga753aade115708d360f25bff422ef1f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc39ba5754615bd82e13302e289651ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#gafc39ba5754615bd82e13302e289651ee">system_phy_set_max_tpw</a> (uint8 max_tpw)</td></tr>
<tr class="memdesc:gafc39ba5754615bd82e13302e289651ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum value of RF TX Power, unit : 0.25dBm.  <a href="#gafc39ba5754615bd82e13302e289651ee">More...</a><br /></td></tr>
<tr class="separator:gafc39ba5754615bd82e13302e289651ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d3301798674f7ed1163f0b2ed333c44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga7d3301798674f7ed1163f0b2ed333c44">system_phy_set_tpw_via_vdd33</a> (uint16 vdd33)</td></tr>
<tr class="memdesc:ga7d3301798674f7ed1163f0b2ed333c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the RF TX Power according to VDD33, unit : 1/1024 V.  <a href="#ga7d3301798674f7ed1163f0b2ed333c44">More...</a><br /></td></tr>
<tr class="separator:ga7d3301798674f7ed1163f0b2ed333c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96d92897e242b7f1bcd484e58f3b4a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__System__APIs.html#ga96d92897e242b7f1bcd484e58f3b4a66">system_phy_set_rfoption</a> (uint8 option)</td></tr>
<tr class="memdesc:ga96d92897e242b7f1bcd484e58f3b4a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable RF or not when wakeup from deep-sleep.  <a href="#ga96d92897e242b7f1bcd484e58f3b4a66">More...</a><br /></td></tr>
<tr class="separator:ga96d92897e242b7f1bcd484e58f3b4a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>System APIs. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaf560461b4a37405f75fd789165f6c576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__System__APIs.html#gaf560461b4a37405f75fd789165f6c576">rst_reason</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf560461b4a37405f75fd789165f6c576af39e71277c3bfc84b75a4a5683531565"></a>REASON_DEFAULT_RST&#160;</td><td class="fielddoc">
<p>normal startup by power on </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf560461b4a37405f75fd789165f6c576a90f8f58c2fec687ee00f4735bf24006d"></a>REASON_WDT_RST&#160;</td><td class="fielddoc">
<p>hardware watch dog reset </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf560461b4a37405f75fd789165f6c576a37032d096425911146ce105004cc8adb"></a>REASON_EXCEPTION_RST&#160;</td><td class="fielddoc">
<p>exception reset, GPIO status won't change </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf560461b4a37405f75fd789165f6c576a57184a4fb4d760f85fd0834566bf6e9c"></a>REASON_SOFT_WDT_RST&#160;</td><td class="fielddoc">
<p>software watch dog reset, GPIO status won't change </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf560461b4a37405f75fd789165f6c576a6d052f0a22d1b1d060a7e017f6152559"></a>REASON_SOFT_RESTART&#160;</td><td class="fielddoc">
<p>software restart ,system_restart , GPIO status won't change </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf560461b4a37405f75fd789165f6c576acee6519d545f6be1bac3e00be8637ee7"></a>REASON_DEEP_SLEEP_AWAKE&#160;</td><td class="fielddoc">
<p>wake up from deep-sleep </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf560461b4a37405f75fd789165f6c576a9ab5cbcccb384a176990019a8e1b2cc8"></a>REASON_EXT_SYS_RST&#160;</td><td class="fielddoc">
<p>external system reset </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga3b49ed94048da366d384364482c5ae43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 system_adc_read </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the input voltage of TOUT pin 6, unit : 1/1024 V. </p>
<dl class="section attention"><dt>Attention</dt><dd>1. system_adc_read can only be called when the TOUT pin is connected to the external circuitry, and the TOUT pin input voltage should be limited to 0~1.0V. </dd>
<dd>
2. When the TOUT pin is connected to the external circuitry, the 107th byte (vdd33_const) of esp_init_data_default.bin(0~127byte) should be set as the real power voltage of VDD3P3 pin 3 and 4. </dd>
<dd>
3. The unit of vdd33_const is 0.1V, the effective value range is [18, 36]; if vdd33_const is in [0, 18) or (36, 255), 3.3V is used to optimize RF by default.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Input voltage of TOUT pin 6, unit : 1/1024 V </dd></dl>

</div>
</div>
<a class="anchor" id="ga2b2d62411a8baa3b7fec777d281397e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_deep_sleep </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>time_in_us</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the chip to deep-sleep mode. </p>
<p>The device will automatically wake up after the deep-sleep time set by the users. Upon waking up, the device boots up from user_init.</p>
<dl class="section attention"><dt>Attention</dt><dd>1. XPD_DCDC should be connected to EXT_RSTB through 0 ohm resistor in order to support deep-sleep wakeup. </dd>
<dd>
2. system_deep_sleep(0): there is no wake up timer; in order to wake up, connect a GPIO to pin RST, the chip will wake up by a falling-edge on pin RST</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint32</td><td>time_in_us : deep-sleep time, unit: microsecond</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="gaaaf7c29067d92bf6c03747b4ad2c2bf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_deep_sleep_set_option </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this API before system_deep_sleep to set the activity after the next deep-sleep wakeup. </p>
<p>If this API is not called, default to be system_deep_sleep_set_option(1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint8</td><td>option : </td></tr>
    <tr><td class="paramname">0</td><td>: Radio calibration after the deep-sleep wakeup is decided by byte 108 of esp_init_data_default.bin (0~127byte). </td></tr>
    <tr><td class="paramname">1</td><td>: Radio calibration will be done after the deep-sleep wakeup. This will lead to stronger current. </td></tr>
    <tr><td class="paramname">2</td><td>: Radio calibration will not be done after the deep-sleep wakeup. This will lead to weaker current. </td></tr>
    <tr><td class="paramname">4</td><td>: Disable radio calibration after the deep-sleep wakeup (the same as modem-sleep). This will lead to the weakest current, but the device can't receive or transmit data after waking up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true : succeed </dd>
<dd>
false : fail </dd></dl>

</div>
</div>
<a class="anchor" id="ga86228f8d572c91ec871684121dad0647"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 system_get_chip_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the chip ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The chip ID. </dd></dl>

</div>
</div>
<a class="anchor" id="ga258edd68184bb78f062a3b375dca997c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 system_get_free_heap_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the size of available heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Available heap size. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f0263b1c227015248c7020e41d787b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrst__info.html">rst_info</a>* system_get_rst_info </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the reason of restart. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>struct rst_info* : information of the system restart </dd></dl>

</div>
</div>
<a class="anchor" id="gaff1e2f744888e01d75bbb1cb2fdee0cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 system_get_rtc_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get RTC time, unit: RTC clock cycle. </p>
<p>Example: If system_get_rtc_time returns 10 (it means 10 RTC cycles), and system_rtc_clock_cali_proc returns 5.75 (it means 5.75 microseconds per RTC clock cycle), (then the actual time is 10 x 5.75 = 57.5 microseconds.</p>
<dl class="section attention"><dt>Attention</dt><dd>System time will return to zero because of system_restart, but the RTC time still goes on. If the chip is reset by pin EXT_RST or pin CHIP_EN (including the deep-sleep wakeup), situations are shown as below: </dd>
<dd>
1. reset by pin EXT_RST : RTC memory won't change, RTC timer returns to zero </dd>
<dd>
2. watchdog reset : RTC memory won't change, RTC timer won't change </dd>
<dd>
3. system_restart : RTC memory won't change, RTC timer won't change </dd>
<dd>
4. power on : RTC memory is random value, RTC timer starts from zero </dd>
<dd>
5. reset by pin CHIP_EN : RTC memory is random value, RTC timer starts from zero</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTC time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga82dfc665528462dbaa945e45512b8c93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* system_get_sdk_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get information of the SDK version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information of the SDK version. </dd></dl>

</div>
</div>
<a class="anchor" id="gaff40fbcef002e346e8f36c378cf75d86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 system_get_time </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get system time, unit: microsecond. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>System time, unit: microsecond. </dd></dl>

</div>
</div>
<a class="anchor" id="gacf1baad08cac941b54b44126045e38cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 system_get_vdd33 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Measure the power voltage of VDD3P3 pin 3 and 4, unit : 1/1024 V. </p>
<dl class="section attention"><dt>Attention</dt><dd>1. system_get_vdd33 depends on RF, please do not use it if RF is disabled. </dd>
<dd>
2. system_get_vdd33 can only be called when TOUT pin is suspended. </dd>
<dd>
3. The 107th byte in esp_init_data_default.bin (0~127byte) is named as "vdd33_const", when TOUT pin is suspended vdd33_const must be set as 0xFF, that is 255.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Power voltage of VDD33, unit : 1/1024 V </dd></dl>

</div>
</div>
<a class="anchor" id="ga753aade115708d360f25bff422ef1f55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_param_load </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>start_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data saved into flash with the read/write protection. </p>
<p>Flash read/write has to be 4-bytes aligned.</p>
<p>Read/write protection of flash: use 3 sectors (4KB per sector) to save 4KB data with protect, sector 0 and sector 1 are data sectors, back up each other, save data alternately, sector 2 is flag sector, point out which sector is keeping the latest data, sector 0 or sector 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint16</td><td>start_sec : start sector (sector 0) of the 3 sectors used for flash read/write protection. It cannot be sector 1 or sector 2.<ul>
<li>For example, in IOT_Demo, the 3 sectors (3 * 4KB) starting from flash 0x3D000 can be used for flash read/write protection. The parameter start_sec is 0x3D, and it cannot be 0x3E or 0x3F. </li>
</ul>
</td></tr>
    <tr><td class="paramname">uint16</td><td>offset : offset of data saved in sector </td></tr>
    <tr><td class="paramname">void</td><td>*param : data pointer </td></tr>
    <tr><td class="paramname">uint16</td><td>len : data length, offset + len =&lt; 4 * 1024</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true : succeed </dd>
<dd>
false : fail </dd></dl>

</div>
</div>
<a class="anchor" id="gae68a7b6345630e42fde3e827108571e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_param_save_with_protect </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>start_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data into flash with protection. </p>
<p>Flash read/write has to be 4-bytes aligned.</p>
<p>Protection of flash read/write : use 3 sectors (4KBytes per sector) to save 4KB data with protect, sector 0 and sector 1 are data sectors, back up each other, save data alternately, sector 2 is flag sector, point out which sector is keeping the latest data, sector 0 or sector 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint16</td><td>start_sec : start sector (sector 0) of the 3 sectors which are used for flash read/write protection.<ul>
<li>For example, in IOT_Demo we can use the 3 sectors (3 * 4KB) starting from flash 0x3D000 for flash read/write protection, so the parameter start_sec should be 0x3D </li>
</ul>
</td></tr>
    <tr><td class="paramname">void</td><td>*param : pointer of the data to be written </td></tr>
    <tr><td class="paramname">uint16</td><td>len : data length, should be less than a sector, which is 4 * 1024</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true : succeed </dd>
<dd>
false : fail </dd></dl>

</div>
</div>
<a class="anchor" id="gafc39ba5754615bd82e13302e289651ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_phy_set_max_tpw </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>max_tpw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum value of RF TX Power, unit : 0.25dBm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint8</td><td>max_tpw : the maximum value of RF Tx Power, unit : 0.25dBm, range [0, 82]. It can be set refer to the 34th byte (target_power_qdb_0) of esp_init_data_default.bin(0~127byte)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga96d92897e242b7f1bcd484e58f3b4a66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_phy_set_rfoption </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable RF or not when wakeup from deep-sleep. </p>
<dl class="section attention"><dt>Attention</dt><dd>1. This API can only be called in user_rf_pre_init. </dd>
<dd>
2. Function of this API is similar to system_deep_sleep_set_option, if they are both called, it will disregard system_deep_sleep_set_option which is called before deep-sleep, and refer to system_phy_set_rfoption which is called when deep-sleep wake up. </dd>
<dd>
3. Before calling this API, system_deep_sleep_set_option should be called once at least.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint8</td><td>option :<ul>
<li>0 : Radio calibration after deep-sleep wake up depends on esp_init_data_default.bin (0~127byte) byte 108.</li>
<li>1 : Radio calibration is done after deep-sleep wake up; this increases the current consumption.</li>
<li>2 : No radio calibration after deep-sleep wake up; this reduces the current consumption.</li>
<li>4 : Disable RF after deep-sleep wake up, just like modem sleep; this has the least current consumption; the device is not able to transmit or receive data after wake up.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d3301798674f7ed1163f0b2ed333c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_phy_set_tpw_via_vdd33 </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>vdd33</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the RF TX Power according to VDD33, unit : 1/1024 V. </p>
<dl class="section attention"><dt>Attention</dt><dd>1. When TOUT pin is suspended, VDD33 can be measured by system_get_vdd33. </dd>
<dd>
2. When TOUT pin is connected to the external circuitry, system_get_vdd33 can not be used to measure VDD33.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint16</td><td>vdd33 : VDD33, unit : 1/1024V, range [1900, 3300]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga3103885b6ff682cac77fea78c2b73425"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_print_meminfo </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the system memory distribution, including data/rodata/bss/heap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga80e0119dbfcaaa43025fe2135d3d1efc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_restart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restart system. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="gae04bb6e4dba5ca53c4f5af629c235bec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_restore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset to default settings. </p>
<p>Reset to default settings of the following APIs : wifi_station_set_auto_connect, wifi_set_phy_mode, wifi_softap_set_config related, wifi_station_set_config related, and wifi_set_opmode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga53909af3917e5dafc57c5a4d75e6ca2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 system_rtc_clock_cali_proc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RTC clock cycle. </p>
<dl class="section attention"><dt>Attention</dt><dd>1. The RTC clock cycle has decimal part. </dd>
<dd>
2. The RTC clock cycle will change according to the temperature, so RTC timer is not very precise.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTC clock period (unit: microsecond), bit11~ bit0 are decimal. </dd></dl>

</div>
</div>
<a class="anchor" id="gac89e6906018b3f4ccd1ba4059f344d5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_rtc_mem_read </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read user data from the RTC memory. </p>
<p>The user data segment (512 bytes, as shown below) is used to store user data.</p>
<p>|&lt;-&mdash; system data(256 bytes) -&mdash;&gt;|&lt;--------&mdash; user data(512 bytes) ------&mdash;&gt;|</p>
<dl class="section attention"><dt>Attention</dt><dd>Read and write unit for data stored in the RTC memory is 4 bytes. </dd>
<dd>
src_addr is the block number (4 bytes per block). So when reading data at the beginning of the user data segment, src_addr will be 256/4 = 64, n will be data length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint8</td><td>src : source address of rtc memory, src_addr &gt;= 64 </td></tr>
    <tr><td class="paramname">void</td><td>*dst : data pointer </td></tr>
    <tr><td class="paramname">uint16</td><td>n : data length, unit: byte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true : succeed </dd>
<dd>
false : fail </dd></dl>

</div>
</div>
<a class="anchor" id="ga669af802153a408dbf9b8b34697e34e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool system_rtc_mem_write </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write user data to the RTC memory. </p>
<p>During deep-sleep, only RTC is working. So users can store their data in RTC memory if it is needed. The user data segment below (512 bytes) is used to store the user data.</p>
<p>|&lt;-&mdash; system data(256 bytes) -&mdash;&gt;|&lt;--------&mdash; user data(512 bytes) ------&mdash;&gt;|</p>
<dl class="section attention"><dt>Attention</dt><dd>Read and write unit for data stored in the RTC memory is 4 bytes. </dd>
<dd>
src_addr is the block number (4 bytes per block). So when storing data at the beginning of the user data segment, src_addr will be 256/4 = 64, n will be data length.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uint8</td><td>src : source address of rtc memory, src_addr &gt;= 64 </td></tr>
    <tr><td class="paramname">void</td><td>*dst : data pointer </td></tr>
    <tr><td class="paramname">uint16</td><td>n : data length, unit: byte</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true : succeed </dd>
<dd>
false : fail </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fe928c2d760669eaa7928b6e00c615c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_uart_de_swap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable UART0 swap. </p>
<p>Use the original UART0, not MTCK and MTDO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
<a class="anchor" id="ga6fc697cba1894da7a66d8816ec590682"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void system_uart_swap </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART0 swap. </p>
<p>Use MTCK as UART0 RX, MTDO as UART0 TX, so ROM log will not output from this new UART0. We also need to use MTDO (U0RTS) and MTCK (U0CTS) as UART0 in hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">null</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>null </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 1 2016 10:19:26 for ESP8266_RTOS_SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
